// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tickets.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTicket = `-- name: CreateTicket :one
INSERT INTO tickets (title, description, status, priority, requester_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, title, description, status, priority, requester_id, assignee_id, created_at, updated_at
`

type CreateTicketParams struct {
	Title       string      `json:"title"`
	Description pgtype.Text `json:"description"`
	Status      string      `json:"status"`
	Priority    string      `json:"priority"`
	RequesterID pgtype.UUID `json:"requester_id"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, createTicket,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.RequesterID,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.RequesterID,
		&i.AssigneeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicketByID = `-- name: GetTicketByID :one
SELECT id, title, description, status, priority, requester_id, assignee_id, created_at, updated_at FROM tickets
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTicketByID(ctx context.Context, id int64) (Ticket, error) {
	row := q.db.QueryRow(ctx, getTicketByID, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.RequesterID,
		&i.AssigneeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTicketsByRequesterPaginated = `-- name: ListTicketsByRequesterPaginated :many
SELECT id, title, description, status, priority, requester_id, assignee_id, created_at, updated_at FROM tickets
WHERE
    requester_id = $1
  AND
    (status = $2 OR $2 IS NULL)
  AND
    (priority = $3 OR $3 IS NULL)
ORDER BY created_at DESC
LIMIT $5
    OFFSET $4
`

type ListTicketsByRequesterPaginatedParams struct {
	RequesterID pgtype.UUID `json:"requester_id"`
	Status      pgtype.Text `json:"status"`
	Priority    pgtype.Text `json:"priority"`
	Offset      int32       `json:"offset"`
	Limit       int32       `json:"limit"`
}

func (q *Queries) ListTicketsByRequesterPaginated(ctx context.Context, arg ListTicketsByRequesterPaginatedParams) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, listTicketsByRequesterPaginated,
		arg.RequesterID,
		arg.Status,
		arg.Priority,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ticket
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.RequesterID,
			&i.AssigneeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTicketsPaginated = `-- name: ListTicketsPaginated :many
SELECT id, title, description, status, priority, requester_id, assignee_id, created_at, updated_at FROM tickets
WHERE
    (status = $1 OR $1 IS NULL)
  AND
    (priority = $2 OR $2 IS NULL)
ORDER BY created_at DESC
LIMIT $4
    OFFSET $3
`

type ListTicketsPaginatedParams struct {
	Status   pgtype.Text `json:"status"`
	Priority pgtype.Text `json:"priority"`
	Offset   int32       `json:"offset"`
	Limit    int32       `json:"limit"`
}

func (q *Queries) ListTicketsPaginated(ctx context.Context, arg ListTicketsPaginatedParams) ([]Ticket, error) {
	rows, err := q.db.Query(ctx, listTicketsPaginated,
		arg.Status,
		arg.Priority,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ticket
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.RequesterID,
			&i.AssigneeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicket = `-- name: UpdateTicket :one
UPDATE tickets
SET
    status = $2,
    assignee_id = $3,
    updated_at = $4
WHERE id = $1
RETURNING id, title, description, status, priority, requester_id, assignee_id, created_at, updated_at
`

type UpdateTicketParams struct {
	ID         int64              `json:"id"`
	Status     string             `json:"status"`
	AssigneeID pgtype.UUID        `json:"assignee_id"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) (Ticket, error) {
	row := q.db.QueryRow(ctx, updateTicket,
		arg.ID,
		arg.Status,
		arg.AssigneeID,
		arg.UpdatedAt,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.RequesterID,
		&i.AssigneeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
